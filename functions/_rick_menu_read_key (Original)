#!/usr/bin/env zsh
# _rick_menu_read_key - Read a single key press including arrow keys
#
# Usage: _rick_menu_read_key
# Returns: A string representing the key pressed

_rick_menu_read_key() {
  local key=""
  local STTY_SAVE=""
  
  # Prevent prompt expansion interference
  local -a precmd_functions
  local -a preexec_functions
  local PROMPT_COMMAND=""
  
  # Set errno to a non-EINTR value to prevent infinite loop in ZSH's sysread
  # This fixes a known bug in ZSH where errno=EINTR causes an infinite loop
  typeset -g errnoval=0
  
  # Standard pattern for guaranteed TTY state preservation with deterministic
  # state transitions for non-blocking reads
  {
    # Save the current terminal settings
    STTY_SAVE=$(stty -g)
    
    # Set terminal to raw mode with explicit parameters to ensure predictable state
    stty raw -echo -icanon min 0 time 0
    
    # Force flush any pending input - multiple approaches for reliability
    zle -I # Force ZLE input flush
    while read -t 0 -k 1 discard_input; do : ; done
    
    # Use a timeout to prevent hanging
    local -i i=0
    local read_success=0
    
    # Now perform the actual read with explicit timeout and multiple retries
    while (( i < 3 )) && (( read_success == 0 )); do
      # Try with progressively longer timeouts
      if read -t 0.$((i+1)) -k 1 key; then
        read_success=1
      fi
      ((i++))
    done
    
    # Handle empty reads with explicit default
    # This prevents the empty string from propagating further
    if [[ -z "$key" ]]; then
      key="TIMEOUT"
    fi
    
  } always {
    # Guaranteed terminal state restoration regardless of how function exits
    stty $STTY_SAVE
    # Additional cleanup to ensure ZLE state is reset
    zle -R
  }
  
  # Process special key sequences with proper timeout handling
  if [[ "$key" == $'\e' ]]; then
    # Could be an escape sequence for special keys
    local seq=""
    local seq2=""
    
    # Read with explicit timeout and error handling
    if ! read -t 0.1 -k 1 seq; then
      echo "escape"
      return
    fi
    
    if [[ "$seq" == "[" ]]; then
      if ! read -t 0.1 -k 1 seq2; then
        echo "escape"
        return
      fi
      
      case "$seq2" in
        A) echo "up" ;;
        B) echo "down" ;;
        C) echo "right" ;;
        D) echo "left" ;;
        H) echo "home" ;;
        F) echo "end" ;;
        *) echo "M-[$seq2" ;;
      esac
    else
      echo "M-$seq"
    fi
  elif [[ "$key" == $'\r' || "$key" == $'\n' ]]; then
    # Enter key
    echo "enter"
  elif [[ "$key" == " " ]]; then
    # Space key
    echo "space"
  elif [[ "$key" == $'\x7f' ]]; then
    # Backspace
    echo "backspace"
  elif [[ "$key" == "TIMEOUT" ]]; then
    # Handle timeout/empty read explicitly
    echo "timeout"
  else
    # Output the key
    echo "$key"
  fi
}

# Execute the function if called directly
if [[ "${FUNCNAME[0]}" == '_rick_menu_read_key' ]]; then
  echo "Press any key to see its representation..."
  key=$(_rick_menu_read_key)
  echo "You pressed: $key"
fi 