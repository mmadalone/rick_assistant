#!/usr/bin/env zsh
# -*- mode: zsh; sh-indentation: 2; indent-tabs-mode: nil; sh-basic-offset: 2; -*-
# vim: ft=zsh sw=2 ts=2 et
#
# Rick Assistant - Autoload Function Framework
# Enables on-demand loading of functions to reduce startup overhead

# Directory for storing autoload function definitions
typeset -g RICK_AUTOLOAD_DIR="${RICK_ASSISTANT_SCRIPT_DIR}/src/core/autoload"

# Track which functions have been requested for autoload
typeset -gA _RICK_AUTOLOAD_REQUESTED

# Track which functions have been loaded
typeset -gA _RICK_AUTOLOAD_LOADED

# Initialize autoload support
_rick_init_autoload() {
  # Ensure autoload directory exists
  if [[ ! -d "$RICK_AUTOLOAD_DIR" ]]; then
    mkdir -p "$RICK_AUTOLOAD_DIR" 2>/dev/null || {
      _rick_error "Failed to create autoload directory: $RICK_AUTOLOAD_DIR"
      return 1
    }
  fi
  
  # Add function path for autoload
  fpath=("$RICK_AUTOLOAD_DIR" $fpath)
  
  [[ -n "$RICK_ASSISTANT_DEBUG" ]] && _rick_debug "Autoload system initialized"
  return 0
}

# Register a function for autoloading
# Usage: rick_register_autoload function_name function_content
rick_register_autoload() {
  local func_name="$1"
  local func_content="$2"
  
  # Check if the function has already been registered
  if [[ -n "${_RICK_AUTOLOAD_REQUESTED[$func_name]}" ]]; then
    [[ -n "$RICK_ASSISTANT_DEBUG" ]] && _rick_debug "Function $func_name already registered for autoload"
    return 0
  fi
  
  # Create function file in autoload directory for reference/debugging
  local func_file="${RICK_AUTOLOAD_DIR}/${func_name}"
  
  # Add function content to file using echo instead of cat (more WSL-friendly)
  echo "#!/usr/bin/env zsh
# Autoloaded function: $func_name
# Generated by Rick Assistant Autoload Framework

$func_content
" > "$func_file"
  
  # Mark function as requested for autoload
  _RICK_AUTOLOAD_REQUESTED[$func_name]=1
  
  # Directly define the function right away - for testing purposes
  if [[ -n "$RICK_ASSISTANT_TESTING" ]]; then
    # In testing mode, we directly define the function
    [[ -n "$RICK_ASSISTANT_DEBUG" ]] && _rick_debug "Directly defining function $func_name (testing mode)"
    # Use ZSH's functions array instead of eval
    functions[$func_name]="$func_content"
    _RICK_AUTOLOAD_LOADED[$func_name]=1
  else
    # In normal mode, set up the lazy loading mechanism
    # Use a temporary file approach instead of complex nested eval
    local temp_file="${RICK_AUTOLOAD_DIR}/.${func_name}_wrapper.zsh"
    
    # Write the wrapper function to a temporary file
    cat > "$temp_file" << EOF
# Temporary wrapper function for $func_name
function $func_name() {
  # First call will load the function
  if [[ -z \${_RICK_AUTOLOAD_LOADED[$func_name]} ]]; then
    [[ -n \$RICK_ASSISTANT_DEBUG ]] && _rick_debug "Loading function: $func_name"
    
    # Mark as loaded first to avoid recursion
    _RICK_AUTOLOAD_LOADED[$func_name]=1
    
    # Remove this wrapper function
    unfunction $func_name
    
    # Source the real implementation
    source "${RICK_AUTOLOAD_DIR}/${func_name}"
    
    # Call the implementation with original arguments
    $func_name "\$@"
    return \$?
  else
    # This should never be reached in normal operation
    _rick_error "Function loading error for $func_name"
    return 1
  fi
}
EOF
    
    # Source the wrapper function
    source "$temp_file"
    
    # Clean up the temporary file
    rm -f "$temp_file"
  fi
  
  [[ -n "$RICK_ASSISTANT_DEBUG" ]] && _rick_debug "Registered $func_name for autoloading"
  return 0
}

# Register a function from a file for autoloading
# Usage: rick_register_autoload_file function_name file_path
rick_register_autoload_file() {
  local func_name="$1"
  local file_path="$2"
  
  # Check if the file exists
  if [[ ! -f "$file_path" ]]; then
    _rick_error "File not found for autoloading: $file_path"
    return 1
  fi
  
  # Read file content
  local func_content=$(cat "$file_path")
  
  # Register function for autoloading
  rick_register_autoload "$func_name" "$func_content"
  return $?
}

# Register a simple command function for autoloading
# This is useful for commands that simply call Python scripts
# Usage: rick_register_command cmd subcommand script [function_name]
rick_register_command() {
  local cmd="$1"
  local subcmd="$2"
  local script_path="${RICK_ASSISTANT_SCRIPT_DIR}/$3"
  local func_name="${4:-_rick_cmd_${cmd}_${subcmd}}"
  
  # Create function content
  local func_content="# Auto-generated command function for: rick $cmd $subcmd
$func_name() {
  # Ensure script exists
  if [[ ! -f \"$script_path\" ]]; then
    echo \"Error: Script not found: $script_path\" >&2
    return 1
  fi
  
  # Run script with arguments
  if command -v python3 >/dev/null 2>&1; then
    PYTHONPATH=\"${RICK_ASSISTANT_SCRIPT_DIR}:\${PYTHONPATH:-}\" python3 \"$script_path\" \"\$@\"
  else
    echo \"Error: Python 3 not found\" >&2
    return 1
  fi
}"
  
  # Register function for autoloading
  rick_register_autoload "$func_name" "$func_content"
  return $?
}

# Check for unused registered functions (debugging)
rick_list_autoload_status() {
  echo "Rick Assistant Autoload Status:"
  echo "-----------------------------"
  echo "Autoload directory: $RICK_AUTOLOAD_DIR"
  echo ""
  echo "Registered functions:"
  
  # List registered functions and their status
  for func in "${(@k)_RICK_AUTOLOAD_REQUESTED}"; do
    local status="Not loaded"
    [[ -n "${_RICK_AUTOLOAD_LOADED[$func]}" ]] && status="Loaded"
    printf "  %-30s %s\n" "$func" "$status"
  done
  
  # Count unused registered functions
  local unused=0
  for func in "${(@k)_RICK_AUTOLOAD_REQUESTED}"; do
    [[ -z "${_RICK_AUTOLOAD_LOADED[$func]}" ]] && ((unused++))
  done
  
  echo ""
  echo "Statistics:"
  echo "  Total registered: ${#_RICK_AUTOLOAD_REQUESTED}"
  echo "  Loaded: ${#_RICK_AUTOLOAD_LOADED}"
  echo "  Not loaded: $unused"
  
  return 0
}

# Add fallback utility functions for testing in isolation
# These will only be defined if they don't already exist
if ! typeset -f _rick_error >/dev/null 2>&1; then
  _rick_error() {
    echo "ERROR: $*" >&2
  }
fi

if ! typeset -f _rick_debug >/dev/null 2>&1; then
  _rick_debug() {
    [[ -n "$RICK_ASSISTANT_DEBUG" ]] && echo "DEBUG: $*" >&2
  }
fi

# Initialize autoload system
_rick_init_autoload 