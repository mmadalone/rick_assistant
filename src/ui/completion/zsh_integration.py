#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZSH Completion Integration Module for Rick Assistant

This module provides functions to integrate Rick Assistant's completion
system with ZSH's built-in completion capabilities.
"""

import os
import sys
import re
import tempfile
import subprocess
import atexit
from typing import List, Dict, Any, Optional, Union, Tuple, Callable

from src.utils.logger import get_logger
from src.utils.errors import safe_execute
from src.utils.path_safety import is_safe_path

from .utils import check_zsh_version, is_wsl

# Initialize logger
logger = get_logger(__name__)

# Path where we'll install our ZSH completion files
ZSH_COMPLETION_DIR = os.path.expanduser("~/.zsh/completions")

# Template for ZSH completion function
ZSH_COMPLETION_TEMPLATE = '''
#compdef {command}

# ZSH completion function for {command}
# Generated by Rick Assistant

{completion_code}

_{command}
'''

@safe_execute(default_return=False)
def setup_zsh_completion(command: str, 
                         completion_function: Callable[[str], List[str]], 
                         description: str = "",
                         install: bool = False) -> bool:
    """
    Set up ZSH completion for a command.
    
    This function creates completion functions for ZSH that call back to
    Rick Assistant's Python-based completion system.
    
    Args:
        command: Command to set up completion for
        completion_function: Python function that provides completions
        description: Description of the command
        install: Whether to permanently install the completion (requires write access)
        
    Returns:
        bool: True if completion was set up successfully, False otherwise
        
    Examples:
        >>> from src.ui.completion import complete_command
        >>> setup_zsh_completion("rick-config", complete_command)
    """
    # Validate input
    if not command or not callable(completion_function):
        logger.error("Invalid command or completion function")
        return False
        
    # Check if ZSH is available
    zsh_version = check_zsh_version()
    if not zsh_version:
        logger.warning("ZSH not found, cannot set up completion")
        return False
        
    logger.info(f"Setting up ZSH completion for '{command}' (ZSH {zsh_version})")
    
    # Generate completion code for ZSH
    completion_code = _generate_zsh_completion_code(command, description)
    
    if install:
        # Create completion directory if it doesn't exist
        try:
            os.makedirs(ZSH_COMPLETION_DIR, exist_ok=True)
        except Exception as e:
            logger.error(f"Error creating completion directory: {e}")
            return False
            
        # Write completion function to file
        completion_file = os.path.join(ZSH_COMPLETION_DIR, f"_{command}")
        try:
            with open(completion_file, 'w') as f:
                f.write(ZSH_COMPLETION_TEMPLATE.format(
                    command=command,
                    completion_code=completion_code
                ))
            logger.info(f"Installed completion for '{command}' to {completion_file}")
            
            # Add completion directory to fpath if needed
            _ensure_fpath_includes_completion_dir()
            
            return True
        except Exception as e:
            logger.error(f"Error writing completion file: {e}")
            return False
    else:
        # Just generate the completion function and return success
        logger.debug(f"Generated completion for '{command}' (not installed)")
        return True

@safe_execute(default_return="")
def _generate_zsh_completion_code(command: str, description: str = "") -> str:
    """
    Generate ZSH completion code for a command.
    
    Args:
        command: Command to generate completion for
        description: Description of the command
        
    Returns:
        str: ZSH completion function code
    """
    # Basic completion function template
    if description:
        description_line = f'    _description "{description}"'
    else:
        description_line = ""
        
    return f'''function _{command}() {{
    local curcontext="$curcontext" state line
    typeset -A opt_args
    
    _arguments -C \\
        '1: :->command' \\
        '*::arg:->args'
    
    case $state in
        command)
{description_line}
            _rick_assistant_complete_command {command}
            ;;
        args)
            _rick_assistant_complete_args {command} $words
            ;;
    esac
}}

function _rick_assistant_complete_command() {{
    local cmd="$1"
    # This would be called by Rick Assistant's Python code
    compadd $(rick-assistant complete "$cmd")
}}

function _rick_assistant_complete_args() {{
    local cmd="$1"
    shift
    local words=("$@")
    # This would be called by Rick Assistant's Python code
    compadd $(rick-assistant complete "$cmd" "${{words[@]}}")
}}'''

@safe_execute(default_return=False)
def _ensure_fpath_includes_completion_dir() -> bool:
    """
    Ensure ZSH's fpath includes our completion directory.
    
    Returns:
        bool: True if successful, False otherwise
    """
    # Check if .zshrc exists
    zshrc_path = os.path.expanduser("~/.zshrc")
    if not os.path.exists(zshrc_path):
        logger.warning("~/.zshrc not found, cannot add completion directory to fpath")
        return False
        
    # Read .zshrc
    try:
        with open(zshrc_path, 'r') as f:
            zshrc_content = f.read()
            
        # Check if completion directory is already in fpath
        if f"fpath=({ZSH_COMPLETION_DIR}" in zshrc_content or f"fpath+=({ZSH_COMPLETION_DIR}" in zshrc_content:
            logger.debug("Completion directory already in fpath")
            return True
            
        # Add completion directory to fpath
        with open(zshrc_path, 'a') as f:
            f.write(f"\n\n# Added by Rick Assistant for completion\nfpath=({ZSH_COMPLETION_DIR} $fpath)\n")
            
        logger.info(f"Added {ZSH_COMPLETION_DIR} to fpath in ~/.zshrc")
        return True
    except Exception as e:
        logger.error(f"Error modifying .zshrc: {e}")
        return False

@safe_execute(default_return=False)
def create_zsh_completion_script() -> bool:
    """
    Create a ZSH script that can be sourced to enable completions.
    
    This creates a script that users can source in their .zshrc
    to enable Rick Assistant completions.
    
    Returns:
        bool: True if successful, False otherwise
    """
    completion_script_path = os.path.expanduser("~/.rick_assistant_completion.zsh")
    
    try:
        with open(completion_script_path, 'w') as f:
            f.write(f'''#!/usr/bin/env zsh
# Rick Assistant ZSH Completion Script
# This file was automatically generated by Rick Assistant
# Source this file in your .zshrc to enable completions

# Add completion directory to fpath
fpath=({ZSH_COMPLETION_DIR} $fpath)

# Load completions
(( $+functions[compdef] )) || autoload -U compinit && compinit -i

# Setup Rick Assistant completion functions
function _rick_assistant_complete() {{
    local completions
    completions=($(rick-assistant complete "$@"))
    compadd -- $completions
}}

# Register completion functions
compdef _rick_assistant_complete rick-config
compdef _rick_assistant_complete rick-help
compdef _rick_assistant_complete rick-enable
compdef _rick_assistant_complete rick-disable
compdef _rick_assistant_complete rick-status
compdef _rick_assistant_complete rick-universe
compdef _rick_assistant_complete rick-info
compdef _rick_assistant_complete rick-quote
compdef _rick_assistant_complete rick-reload
compdef _rick_assistant_complete rick-debug

# Display a brag from Rick
echo "*burp* I just made your ZSH completions smarter. You're welcome."
''')
        
        # Make the script executable
        os.chmod(completion_script_path, 0o755)
        
        logger.info(f"Created ZSH completion script at {completion_script_path}")
        logger.info(f"To use, add 'source {completion_script_path}' to your ~/.zshrc")
        
        return True
    except Exception as e:
        logger.error(f"Error creating completion script: {e}")
        return False

@safe_execute(default_return=None)
def get_zsh_completion_info() -> Optional[Dict[str, Any]]:
    """
    Get information about the ZSH completion system.
    
    Returns:
        Optional[Dict[str, Any]]: Information about ZSH completion system, or None if unavailable
    """
    # Check if ZSH is available
    zsh_version = check_zsh_version()
    if not zsh_version:
        return None
        
    # Run a ZSH command to get completion system info
    try:
        # Create a temporary script
        fd, temp_path = tempfile.mkstemp(suffix='.zsh', prefix='rick_completion_info_')
        try:
            with os.fdopen(fd, 'w') as f:
                f.write('''
#!/usr/bin/env zsh
echo "VERSION:$ZSH_VERSION"
echo "COMPLETION:$(whence -w compdef | cut -d' ' -f2)"
echo "FPATH:$fpath"
echo "COMPINIT:$(typeset -f compinit >/dev/null && echo 'available' || echo 'unavailable')"
echo "PLUGIN_MANAGERS:$(grep -l "oh-my-zsh\\|antigen\\|zinit\\|zplugin\\|zplug\\|zgen" ~/.zshrc 2>/dev/null && echo 'detected' || echo 'none')"
echo "COMPDIR:$(grep -l "completion" ~/.zshrc 2>/dev/null && echo 'detected' || echo 'none')"
                ''')
                
            # Make the script executable
            os.chmod(temp_path, 0o755)
            
            # Run the script
            result = subprocess.run(
                ['zsh', temp_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                timeout=2.0
            )
            
            if result.returncode == 0:
                # Parse the output
                info = {}
                for line in result.stdout.strip().split('\n'):
                    if ':' in line:
                        key, value = line.split(':', 1)
                        info[key] = value
                        
                return info
        finally:
            # Clean up temporary file
            try:
                os.unlink(temp_path)
            except:
                pass
    except Exception as e:
        logger.error(f"Error getting ZSH completion info: {e}")
        
    return None 