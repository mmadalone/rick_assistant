#!/usr/bin/env zsh
# _rick_menu_navigate - Display an interactive menu with arrow key navigation
#
# Usage: _rick_menu_navigate [-t title] [-w width] [-p prefix] item1 item2 ...
# Returns: The selected item index (1-based) or 0 if cancelled

# Global state tracking to prevent unnecessary redraws
typeset -gA _RICK_MENU_LAST_STATE

_rick_menu_navigate() {
  # Parse options
  local title="Menu"
  local width=60
  local prefix=""
  
  while [[ $# -gt 0 && "$1" == -* ]]; do
    case "$1" in
      -t) title="$2"; shift 2 ;;
      -w) width="$2"; shift 2 ;;
      -p) prefix="$2"; shift 2 ;;
      *) break ;;
    esac
  done
  
  # If no items provided, return error
  if [[ $# -eq 0 ]]; then
    return -1
  fi
  
  # Store menu items
  local -a menu_items
  local i=1
  while [[ $# -gt 0 ]]; do
    menu_items[$i]="$1"
    ((i++))
    shift
  done
  
  # Calculate terminal width if not specified
  if [[ "$width" -le 0 ]]; then
    width=$(tput cols 2>/dev/null || echo 80)
    width=$((width - 4))  # Account for margins
  fi
  
  # Current selected item (1-based indexing)
  local current=1
  local max=${#menu_items[@]}
  local selected=0
  local key
  
  # Initial render
  _rick_menu_render "$title" $width $current "${menu_items[@]}"
  
  # Set trap to ensure terminal state is reset on exit
  trap 'tput cnorm; stty sane; clear; return 0' EXIT INT TERM
  
  # Display menu until selection is made
  while true; do
    # Counter for empty/timeout responses
    local empty_count
    (( empty_count = ${empty_count:-0} + 1 ))
    
    # Read a key
    key=$(_rick_menu_read_key)
    
    # Handle timeout explicitly
    if [[ "$key" == "timeout" ]]; then
      # If we get too many timeouts in a row, break the loop
      if (( empty_count > 5 )); then
        clear
        echo "Too many empty responses - exiting menu"
        return 0
      fi
      # Just continue the loop on timeout
      continue
    fi
    
    # Reset empty count on successful key read
    empty_count=0
    
    # Handle the key
    case "$key" in
      up|down)
        # Update current selection
        local previous=$current
        current=$(_rick_menu_handle_key "$key" "$current" "$max")
        
        # Only redraw if selection changed
        if [[ $previous != $current ]]; then
          _rick_menu_render "$title" $width $current "${menu_items[@]}"
        fi
        ;;
      enter|" ")
        # Return the selected index
        selected=$current
        break
        ;;
      q|Q)
        # Cancel the menu
        selected=0
        break
        ;;
      [1-9])
        # Direct selection via number
        if [[ $key -le $max ]]; then
          selected=$key
          break
        fi
        ;;
    esac
  done
  
  # Clear screen
  clear
  
  # Return the selected item index (1-based, 0 = cancelled)
  return $selected
}

# Efficient menu rendering with buffering
_rick_menu_render() {
  local title="$1"
  local width="$2"
  local current="$3"
  shift 3
  
  # Create buffer for the entire screen
  local -a buffer=()
  
  # Hide cursor and position at top
  buffer+=("$(tput civis)")
  buffer+=("$(tput cup 0 0)")
  
  # Add title if provided
  if [[ -n "$title" ]]; then
    buffer+=("%F{cyan}${(l:$width::-:):-}%f\n")
    
    # Center the title
    local padding=$(( (width - ${#title}) / 2 ))
    padding=$(( padding < 0 ? 0 : padding ))
    buffer+=("$(printf "%${padding}s%s\n" "" "$title")")
    
    buffer+=("%F{cyan}${(l:$width::-:):-}%f\n\n")
  fi
  
  # Add menu items
  local i
  local item_count=$#
  for i in {1..${item_count}}; do
    local item=$@[$i]
    if [[ $i -eq $current ]]; then
      buffer+=(" %F{yellow}→ ${item}%f\n")
    else
      buffer+=("   %F{green}${item}%f\n")
    fi
  done
  
  # Add footer
  buffer+=("\n%F{cyan}${(l:$width::-:):-}%f\n")
  
  # Center the navigation help
  local help_text="↑/↓: Navigate | Enter: Select | q: Cancel"
  local help_padding=$(( (width - ${#help_text}) / 2 ))
  help_padding=$(( help_padding < 0 ? 0 : padding ))
  buffer+=("$(printf "%${help_padding}s%s\n" "" "$help_text")")
  
  buffer+=("%F{cyan}${(l:$width::-:):-}%f\n")
  
  # Show cursor
  buffer+=("$(tput cnorm)")
  
  # Render the entire buffer at once
  print -P "${(j::)buffer}"
}

# Execute the function if called directly
if [[ "${FUNCNAME[0]}" == '_rick_menu_navigate' ]]; then
  _rick_menu_navigate "$@"
  echo "Selected: $?"
fi 